# Homework 06 — мультиметод для пар мудростей

**Дата сдачи:** 01.12.2025

## Выполненные работы
- Реализован мультиметод с двумя аргументами, анализирующий все пары элементов контейнера.
- Для каждой комбинации типов (афоризм/пословица) формируется уникальная фраза, которую нельзя получить конкатенацией отдельных описаний.
- Применён паттерн «регистрация обработчиков»: новые комбинации добавляются через отдельные единицы компиляции без изменения существующего кода.

## Анализ изменений («боль» расширения)

### Процедурная версия
| Метрика | Значение |
| --- | --- |
| Новых файлов | 3 (`multimethod.h`, `multimethod.cpp`, `multimethod_handlers_basic.cpp`) |
| Новых строк кода | ~110 |
| Изменённых старых файлов | 1 (`main.cpp` — добавлен вызов и аргумент) |
| Изменённых строк в старых файлах | ~10 |

### Объектно-ориентированная версия
| Метрика | Значение |
| --- | --- |
| Новых файлов | 3 (`multimethod.h`, `multimethod.cpp`, `multimethod_handlers_basic.cpp`) |
| Новых строк кода | ~120 |
| Изменённых старых файлов | 1 (`main.cpp`) |
| Изменённых строк в старых файлах | ~10 |

### Сравнение подходов
- **Оба подхода** демонстрируют низкую «боль»: существующий код (парсер, контейнер, классы альтернатив) остался полностью неизменным.
- **Процедурный подход**: обработчики проверяют тип через `WisdomType` enum — простая реализация, но менее типобезопасная.
- **ООП-подход**: использует `dynamic_cast` для определения типа — типобезопасно, но требует RTTI.
- **Архитектурное решение**: паттерн регистрации обработчиков позволяет добавлять новые комбинации без перекомпиляции существующих модулей.

## Структурные изменения
- Добавлены `procedural/multimethod.{h,cpp}` и `procedural/multimethod_handlers_basic.cpp`.
- Добавлены `oop/multimethod.{h,cpp}` и `oop/multimethod_handlers_basic.cpp`.
- Клиентский `main.cpp` в обеих версиях принимает четвёртый аргумент (файл для вывода пар).
- Добавлены эталонные файлы `tests/output_*_pairs.txt`.

## Наблюдения
- Мультиметод реализован как **отдельный модуль**, не затрагивающий классы альтернатив — это соответствует принципу Open/Closed.
- Расширение на новые типы (задание №7) потребует только добавления новых обработчиков, без изменения существующих.

---

# Homework 07 — расширение мультиметода альтернативой «Загадка»

**Дата сдачи:** 03.12.2025

## Выполненные работы
- Добавлены обработчики для всех 5 новых комбинаций с альтернативой «Загадка»:
  1. Афоризм + Загадка
  2. Загадка + Афоризм
  3. Пословица + Загадка
  4. Загадка + Пословица
  5. Загадка + Загадка
- Каждая комбинация имеет собственную уникальную фразу.

## Анализ изменений («боль» расширения)

### Процедурная версия
| Метрика | Значение |
| --- | --- |
| Новых файлов | 1 (`multimethod_handlers_riddle.cpp`) |
| Новых строк кода | ~57 |
| Изменённых старых файлов | 0 |
| Изменённых строк в старых файлах | 0 |

### Объектно-ориентированная версия
| Метрика | Значение |
| --- | --- |
| Новых файлов | 1 (`multimethod_handlers_riddle.cpp`) |
| Новых строк кода | ~61 |
| Изменённых старых файлов | 0 |
| Изменённых строк в старых файлах | 0 |

### Сравнение с классическим подходом
Если бы мультиметод был реализован через двойную диспетчеризацию (виртуальные методы в классах), добавление «Загадки» потребовало бы:
- Изменить базовый класс `WisdomEntry` (добавить `DescribeFromRiddle`)
- Изменить **все** существующие классы (`Aphorism`, `Proverb`) для реализации нового метода
- Это ~15-20 изменённых строк в 4-5 файлах

**Паттерн регистрации обработчиков** позволил добавить новую альтернативу **без изменения ни одной существующей строки кода** — только добавление нового файла.

## Структурные изменения
- Добавлены `procedural/multimethod_handlers_riddle.cpp` и `oop/multimethod_handlers_riddle.cpp`.
- Обновлены эталонные файлы `tests/output_*_riddle_pairs.txt`.

## Наблюдения
- Переход от Homework06 к Homework07 выполнен исключительно добавлением новых файлов.
- Архитектура с регистрацией обработчиков подтвердила свою эффективность: расширение полностью «безболезненное».
- **Количество изменённых старых файлов: 0** — это идеальный результат с точки зрения принципа Open/Closed.
