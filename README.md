# ИЗ-1: «Кладезь мудрости»

Две независимые версии консольного приложения читают описание афоризмов и пословиц из текстового файла и выводят итоговый список в новый файл. Процедурный вариант опирается на структуры данных и свободные функции, а ООП-вариант реализует иерархию классов, фабрику и контейнер на основе `std::list`.

## Структура репозитория
- `procedural/` — исходники процедурной реализации (`struct` + свободные функции).
- `oop/` — объектно-ориентированная реализация с наследованием и виртуальными методами.
- `tests/` — тестовые входные файлы и примеры результатов работы.

## Сборка и запуск
```bash
# Процедурная версия
c++ -std=c++17 procedural/main.cpp procedural/wisdom.cpp -o procedural/procedural_app
./procedural/procedural_app tests/input3.txt tests/output_proc.txt

# ООП-версия
c++ -std=c++17 oop/*.cpp -o oop/oop_app
./oop/oop_app tests/input3.txt tests/output_oop.txt
```

## Метрики
| Версия        | Всего модулей (`.h/.cpp`) | Заголовки | Реализации | Ключевые артефакты | Размер исходников |
|---------------|---------------------------|-----------|-------------|---------------------|--------------------|
| Процедурная   | 3                         | 1         | 2           | 2 структуры         | 7289 B             |
| ООП           | 13                        | 6         | 7           | 5 классов           | 11798 B            |

**Артефакты (процедурно):** `Wisdom`, `WisdomList`.  
**Артефакты (ООП):** `WisdomEntry`, `Aphorism`, `Proverb`, `WisdomCollection`, `WisdomFactory`.

## Тестовые файлы
- `tests/input1.txt` — пустой файл (0 объектов).
- `tests/input2.txt` — один афоризм.
- `tests/input3.txt` — смешанный список из пяти корректных записей.
- `tests/input4.txt` — содержит неизвестный тип (`legend`) и демонстрирует обработку ошибки.
- `tests/input5.txt` — ошибка формата (отсутствуют кавычки у содержимого пословицы).
- `tests/output_proc_valid.txt`, `tests/output_oop_valid.txt` — примеры корректного вывода для `input3.txt`.

## Основные впечатления
Процедурный вариант оказался проще для первоначальной сборки: достаточно объявить пару структур и функций, не нужно думать о виртуальных методах и регистрации типов. Однако уже при обработке ошибок и форматирования вывода чувствуется ограничение: любая новая разновидность «мудрости» потребовала бы расширения `enum` и переписывания нескольких функций сразу.

ООП-подход требует большего количества файлов и начальной настройки (иерархия, фабрика, контейнер). Зато добавление нового типа вроде «загадок» сведётся к созданию класса-наследника и регистрации его в фабрике — существующий код коллекции и вывода менять не придётся. Основная сложность здесь была в аккуратной организации модулей и избегании проблем с неполными типами при работе со `std::unique_ptr`.

В целом, для дальнейшей эволюции и частого расширения модель с полиморфизмом выглядит устойчивее: она делает зависимость от разновидностей данных явной и локализует изменения. Процедурная версия остаётся лёгкой и прозрачной для малых объёмов, но масштабируется заметно хуже.
